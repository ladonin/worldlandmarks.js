нет вьюх и лэйаутов
cataolg_page_article_items_list cataolg_page_article_item
в world-landmarks.ru фраза 'смотреть все' (для статей) только на русском

в react добаить keys в массивы
кешироват ькак можно больше данных

snapshot_fields_data() в конце каждого конструктора исходной модели
при сбрасывании fields тоже клонирование, а не передача по ссылке

ERROR_USER_NOT_VERIFICATED - в catch в application.run() сделать проверку на него и показать страницу для ERROR_USER_NOT_VERIFICATED

при каждом обращении к серверу в before нужно сбрасывать account свойства (role, id и т.д.)

все статические настройки одинаковые между запросами - писать в приватные переменные модулей

в начале run() security выполнять:
    Security.init()
    инициироват responce и request base-компоненты (передавать request'у query)
    ErrorHandler.reset()

var1 и var2 переименовал в controller и action

переименовал таблицы
1. country_states_cities_google_translates => country_states_cities_translations
2. country_states_google_names => country_states_names

landmarks_map_data.comment, comment_plain, title теперь могут быть пустыми и по дефолту равны NULL, NULL и '' - исправить в таблице будущего прода


в базе данных country_code и state_code - сделать ссылками на основную таблицу и заменить на country_id и state_id
is_ методы заменить на wherher_

add_new_point_form[delete_photos][5d3773dcbb04a478.jpeg] value="1" - заменить на add_new_point_form[delete_photos][] value="5d3773dcbb04a478.jpeg"


Map.createNewPoint() как вернет результат - если в результате есть email (проверенный уже) - то в клиенте установить куку COOKIE_EMAIL_PLACEMARK,
которая будет вставляться в форму создания новой метки

есть ссылки прямые в бэкэнде, помечены они так: //ATTENTION - обратите внимание - прямая ссылка










//ATTENTION - обратите внимание

#???????????????????????????? - то, что возможно не нужно
nextTTTTTTTTTTTT - продолжать с этого момента





import { withRouter } from 'react-router-dom';
    constructor() {
        super();
        this.goTo = this.goTo.bind(this);
    }
    goTo(event) {
        this.props.history.push(event.target.dataset.url);
    }
onClick={this.goTo} data-url="catalog"
export default withRouter(MainLinks);






//if (process.env.NODE_ENV === Consts.PROCESS_PROD) {

field['value'] = field['value'].replace(/\[strong\](.+?)\[\/strong\]/g, '<strong>$1</strong>');
//монструозная регулярка
                        field['value'] = field['value'].replace(/\[p\]((?:.*?[\n\r]?.*?)*?)\[\/p\][\n\r]*/gm, function(matches, part1) {
                            return '<p class="text_form_tag_p">'+part1.replace(/[\r\n]*/g, '')+'</p>';
                        });







// если ftp  опять бужет не работать
const Deasync = require('deasync');
const jsftp = require("jsftp");
const Ftp = new jsftp({
  host: "140706.selcdn.ru",
  port: 21, // defaults to 21
  user: "40679", // defaults to "anonymous"
  pass: "XrhbDnXv" // defaults to "@anonymous"
});
let _finished = false;
Ftp.ls('/mapstore/s/s/', (err, res) => {
  console.log(res);_finished = true;
});
// Wait for convertation to be finished
Deasync.loopWhile(function () {
    return !_finished;
});
let arr = ['/mapstore/s/s/11111111.jpg','/mapstore/s/s/2222222222.jpg','/mapstore/s/s/3333333333333333333333.jpg'];
for (let index in arr) {
    let file = arr[index];
_finished = false;

Ftp.put("application/../files/2.jpg", file, err => {
  if (!err) {
    console.log("File transferred successfully!");
  }_finished = true;
});
// Wait for convertation to be finished
Deasync.loopWhile(function () {
    return !_finished;
});
}
Ftp.get("/mapstore/s/s/1.txt", "application/../files/file62.txt", err => {
  if (err) {
    return console.error("There was an error retrieving the file.");
  }
  console.log("File copied successfully!");
});